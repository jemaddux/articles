Last week Tim Berglund (@tlberglund), a member of GitHub’s training team, came to visit us at gSchool. We've been using Git for several weeks, but Tim was coming to take our knowledge deeper down the rabbit hole.

Tim started out with what he called the “Hipster Git Commit”. Instead of `git init`, which is "so over", Tim went through the process of manually creating a repository. We all sat slack-jawed as he quickly hand crafted the files and folders, normally hidden away, for a Git repository. 

Despite just being an impressive exercise, there was a method to his madness. Building things up piece-by-piece the hard way showed us why the easy way worked at all. Now when I type simple commands like `git add` and `git commit` I understand, at least in theory, how Git is doing the hard work. It took away the ‘magic’ of ‘this just works’ and gave us an idea of how all the plumbing fits together.

Tim also went over Git's outer layer, the command line instructions, and how they had been designed. His analogy was that Git is like an onion. The outer layer is the one that you will interact with most of the time (hopefully it won’t make you cry too much) and it has thus been created to cover the majority of normal functionality. Under this layer is the second skin of the onion (which is still a very well documented and accessible layer) that you can use to work on more difficult Git tasks. The friendlier outer layer is actually built upon the tools from the inner layer. That design pattern allows for advanced functionality while maintaining overall simplicity.

After our journey into Git Wonderland, Tim talked us through the difference between git merge, git rebase, and the debate that surrounds them. He showed us how git commits work, how rebasing works and what the difference between rebasing and committing is. They both merge separate commits into a new commit and thus let programmers share code through a series of commits. With git merge they seem to make a few more commits to the commit log while with a rebase the same thing sorta happens but the commit log is shorter and there is an outside chance that doing this improperly will render another programmers commits worthless.

The ‘war’ that surrounds git merge vs git rebase has to do with team workflow and keeping everyone working smoothly together. The rebasing is essentially rewriting the history of a branch and pretending that it was really written later than it was. It means that there will be fewer commit branches hanging around making the whole project look like a train station’s railyard. The merging approach means that different people can work on their different feature branches easily, but it creates a messier history. Tim's conclusion was that that they both work when used properly and that since many teams have a very pronounced preference for one or the other, as a programmer, you should be able to use both. 

I am sure that all of my fellow gSchoolers will join me in thanking Tim Berglund for teaching us more about Git and especially to GitHub for sending him our way. By helping us understand the inner workings, he significantly helped build our comfort and understanding of this critical tool.
